%% Read the texture image and convert it into grayscale (it was RGB)
I = imread('wallTex_Brightened.jpg');
I = rgb2gray(I);
imshow(I)

%% Find out the edges on the texture
BW = edge(I, 'Canny');
figure, imshow(BW)

%% Calculate the position of the dots on the edges relative to the room:
% Notes:
% 	1. The size of the texture is 1024X1024;
%   2. Should include the dots on the edges of the walls (e.g., between the floor and walls, etc)

[row, col] = find(BW);

nDots = length(row);

% Room specs
height = 3;
width = 12;
depth = 12;

doorway_distance = 7;

% Floor (scale = 1:1)
floor_z = - row/1024 * depth + doorway_distance;
floor_x = col/1024 * width - width/2;
floor_y = zeros(size(floor_x));

floor_pos = [floor_x, floor_y, floor_z];

doorway_width = 0.5;
doorway_height = 2.5;

% Ceiling (scale = 1:1)
ceiling_z = row/1024 * depth - (depth - doorway_distance);
ceiling_x = col/1024 * width - width/2;
ceiling_y = floor_y + height;
ceiling_pos = [ceiling_x, ceiling_y, ceiling_z];

% Left wall (scale on the height = 1:4, so only the bottom third of the texture image was attached)
height_val = -col/1024 * depth + depth;
height_ind = find(height_val >=0 & height_val <= height);

left_y = height_val(height_ind);
left_z = row(height_ind)/1024 * depth - (depth - doorway_distance);
left_x = zeros(size(left_y)) - width/2;

left_pos = [left_x, left_y, left_z];

% Right wall (scale on the height = 1:4)
right_y = height_val(height_ind);
right_z = -row(height_ind)/1024 * depth + doorway_distance;
right_x = zeros(size(right_y)) + width/2;

right_pos = [right_x, right_y, right_z];

% Front wall (note that it contains three parts)
front_y_all = height_val(height_ind);
front_x_all = row(height_ind)/1024 * width - width/2;

front_x_1   = front_x_all(front_x_all <= -doorway_width/2);
front_y_1   = front_y_all(find(front_x_all <= -doorway_width/2));

front_x_2   = front_x_all(front_x_all >= doorway_width/2);
front_y_2   = front_y_all(find(front_x_all >= doorway_width/2));

door_y = height_val(height_val <=0.5) + doorway_height;
door_x = row(height_val <= 0.5)/1024 * 12 - doorway_width/2;

door_d = find(door_x > -doorway_width/2 & door_x <= doorway_width/2);

door_x = door_x(door_d);
door_y = door_y(door_d);

door_line_y_1 = [0:width/2048:doorway_height]';
door_line_x_1 = zeros(size(door_line_y_1)) - doorway_width/2;

door_line_y_2 = [0:width/2048:doorway_height]';
door_line_x_2 = zeros(size(door_line_y_1)) + doorway_width/2;

door_tp_x = [-doorway_width/2: doorway_width/1024: doorway_width/2]';
door_tp_y = zeros(size(door_tp_x)) + doorway_height;

door_bt_x = door_tp_x;
door_bt_y = zeros(size(door_tp_x));

front_x = [front_x_1; front_x_2; door_x; door_line_x_1; door_line_x_2; door_bt_x; door_tp_x];
front_y = [front_y_1; front_y_2; door_y; door_line_y_1; door_line_y_2; door_bt_y; door_tp_y];
front_z = zeros(size(front_x)) + doorway_distance;

front_pos = [front_x, front_y, front_z];

% Put all the dots together
room_dots_pos = [floor_pos; ceiling_pos; left_pos; right_pos; front_pos];

%  Add label: 
%  		0 - no restriction (given that the pattern is randomised noise, so no restriction is imposed on the direction of the flow vector generated by the dots)
room_labels = zeros(size(room_dots_pos, 1), 1);

room_dots_pos = [room_dots_pos, room_labels];

% Find out those on the doorway and add the label
idx = find(room_dots_pos(:, 1) == -doorway_width/2 & room_dots_pos(:, 2) < doorway_height);
room_dots_pos(idx, 4) = 2; % Label "2" as it is on a vertical edge

idx = find(room_dots_pos(:, 1) == doorway_width/2 & room_dots_pos(:, 2) < doorway_height);
room_dots_pos(idx, 4) = 2; % Label "2" as it is on a vertical edge

idx = find(room_dots_pos(:, 1) >= -doorway_width/2 & room_dots_pos(:, 1) <= doorway_width/2 & room_dots_pos(:, 2) == doorway_height);
room_dots_pos(idx, 4) = 1; % Label "1" as it is on a horizontal edge

idx = find(room_dots_pos(:, 1) >= -doorway_width/2 & room_dots_pos(:, 1) <= doorway_width/2 & room_dots_pos(:, 2) == 0 & room_dots_pos(:, 3) == doorway_distance);
room_dots_pos(idx, 4) = 1; % Label "1" as it is on a horizontal edge

%% Check the sample dots in 3D space
figure;
scatter3(room_dots_pos(:, 1), room_dots_pos(:, 3), room_dots_pos(:, 2), 0.75, 'filled')

%% Plot the sampled dots viewed from starting point ([0, 0]) at the height of 1.5m
spv_x = room_dots_pos(:, 1)./room_dots_pos(:, 3);
spv_y = (room_dots_pos(:, 2) - 1.5)./room_dots_pos(:, 3);

fh = figure('Menu','none','ToolBar','none');
ah = axes('Units','Normalize','Position',[0 0 1 1]);
scatter(atand(spv_x), atand(spv_y), 0.75, 'filled')
xlim([-45 45])
ylim([-25 25])
set(gca,'XTick',[]);
set(gca,'YTick',[]);
box on
set(gcf, 'Units', 'centimeters', 'OuterPosition', [5, 5, 21, 14]);

savefig(['SampledDots'])
print(['SampledDots'], '-dsvg')

%% Export the position of the dots on the wall
dlmwrite('Room_positions.csv', room_dots_pos,'delimiter',',');

%% Calculate the position of the sampled dots relative to the viewer

% If no 'Room_positions.csv' in the folder and/or you have gone through the process above
dotPosition = room_dots_pos;

% If 'Room_positions.csv' already exists, can start here
% dotPosition = readtable('Room_positions.csv');
% dotPosition = table2array(dotPosition);

% Calculate the relative position
eye_height = 1.5;
distance_to_target = 6;

dotPosition(:, 2) = dotPosition(:, 2) - eye_height;
dotPosition(:, 3) = dotPosition(:, 3) - (doorway_distance - distance_to_target);

% Get rid of those sampled dots that are behind the viewer
dotPosition = dotPosition(dotPosition(:, 3) > 0, :); 

% Check the sample dots in 3D space
figure;
scatter3(dotPosition(:, 1), dotPosition(:, 3), dotPosition(:, 2), 0.75, 'filled')

% Save the dot positions
save('dotPosition', 'dotPosition')

