%% Read the texture image and convert it into grayscale (it was RGB)
I = imread('wallTex_Brightened.jpg');
I = rgb2gray(I);
imshow(I)

%% Find out the edges on the texture
BW = edge(I, 'Canny');
figure, imshow(BW)

%% Calculate the position of the dots on the edges relative to the room:
% Notes:
% 	1. The size of the texture is 1024X1024;
%   2. Should include the dots on the edges of the walls (e.g., between the floor and walls, etc)

BW(:, 1) = 1;
BW(1, :) = 1;
BW(:, end) = 1;
BW(end, :) = 1;

[row, col] = find(BW);

nDots = length(row);

% Room specs
height = 3;
width = 12;
depth = 12;

doorway_distance = 7;

% Floor (scale = 1:1)
floor_z = - row/1024 * depth + doorway_distance;
floor_x = col/1024 * width - width/2;
floor_y = zeros(size(floor_x));

floor_pos = [floor_x, floor_y, floor_z];

doorway_width = 0.5;
doorway_ceiling_distance = 2.5;

% Ceiling (scale = 1:1)
ceiling_z = row/1024 * depth - (depth - doorway_distance);
ceiling_x = col/1024 * width - width/2;
ceiling_y = floor_y + height;
ceiling_pos = [ceiling_x, ceiling_y, ceiling_z];

% Left wall (scale on the height = 1:4, so only the bottom third of the texture image was attached)
height_val = -col/1024 * depth + depth;
height_ind = find(height_val >=0 & height_val <= height);

left_y = height_val(height_ind);
left_z = row(height_ind)/1024 * depth - (depth - doorway_distance);
left_x = zeros(size(left_y)) - width/2;

left_pos = [left_x, left_y, left_z];

% Right wall (scale on the height = 1:4)
right_y = height_val(height_ind);
right_z = -row(height_ind)/1024 * depth + doorway_distance;
right_x = zeros(size(right_y)) + width/2;

right_pos = [right_x, right_y, right_z];

% Front wall (note that it contains three parts)
front_y_all = height_val(height_ind);
front_x_all = row(height_ind)/1024 * width - width/2;

front_x_1   = front_x_all(front_x_all <= -doorway_width/2);
front_y_1   = front_y_all(find(front_x_all <= -doorway_width/2));

front_x_2   = front_x_all(front_x_all >= doorway_width/2);
front_y_2   = front_y_all(find(front_x_all >= doorway_width/2));

door_y = height_val(height_val <=0.5) + doorway_ceiling_distance;
door_x = row(height_val <= 0.5)/1024 * 12 - doorway_width/2;

door_d = find(door_x > -doorway_width/2 & door_x <= doorway_width/2);

door_x = door_x(door_d);
door_y = door_y(door_d);

door_line_y_1 = [0:width/2048:doorway_ceiling_distance]';
door_line_x_1 = zeros(size(door_line_y_1)) - doorway_width/2;

door_line_y_2 = [0:width/2048:doorway_ceiling_distance]';
door_line_x_2 = zeros(size(door_line_y_1)) + doorway_width/2;

door_bt_x = door_x(find(door_y == doorway_ceiling_distance));
door_bt_y = door_y(door_y == doorway_ceiling_distance) - doorway_ceiling_distance;

front_x = [front_x_1; front_x_2; door_x; door_line_x_1; door_line_x_2; door_bt_x];
front_y = [front_y_1; front_y_2; door_y; door_line_y_1; door_line_y_2; door_bt_y];
front_z = zeros(size(front_x)) + doorway_distance;

front_pos = [front_x, front_y, front_z];

% Put all the dots together
room_dots_pos = [floor_pos; ceiling_pos; left_pos; right_pos; front_pos];

%  Add label: 
%  		0 - no restriction (given that the pattern is randomised noise, so no restriction is imposed on the direction of the flow vector generated by the dots)
room_labels = zeros(size(room_dots_pos, 1), 1);

room_dots_pos = [room_dots_pos, room_labels];

% Find out those on the doorway
idx = find(room_dots_pos(:, 1) == -doorway_width/2 & room_dots_pos(:, 2) < doorway_ceiling_distance);
room_dots_pos(idx, 4) = 2;

idx = find(room_dots_pos(:, 1) == doorway_width/2 & room_dots_pos(:, 2) < doorway_ceiling_distance);
room_dots_pos(idx, 4) = 2;

idx = find(room_dots_pos(:, 1) >= -doorway_width/2 & room_dots_pos(:, 1) <= doorway_width/2 & room_dots_pos(:, 2) == doorway_ceiling_distance);
room_dots_pos(idx, 4) = 1;

idx = find(room_dots_pos(:, 1) >= -doorway_width/2 & room_dots_pos(:, 1) <= doorway_width/2 & room_dots_pos(:, 2) == 0 & room_dots_pos(:, 3) == doorway_distance);
room_dots_pos(idx, 4) = 1;

%% Plot the sampled dots viewed from starting point ([0, 0]) at the height of 1.5m
spv_x = room_dots_pos(:, 1)./room_dots_pos(:, 3);
spv_y = (room_dots_pos(:, 2) - 1.5)./room_dots_pos(:, 3);

fh = figure('Menu','none','ToolBar','none');
ah = axes('Units','Normalize','Position',[0 0 1 1]);
scatter(atand(spv_x), atand(spv_y), 1, 'filled')
xlim([-45 45])
ylim([-25 25])
set(gca,'XTick',[]);
set(gca,'YTick',[]);
box on
set(gcf, 'Units', 'centimeters', 'OuterPosition', [5, 5, 21, 14]);

savefig(['SampledDots'])
print(['SampledDots'], '-dsvg')

%% Export the position of the dots on the wall
dlmwrite('Room_positions.csv', room_dots_pos,'delimiter',',');

%% Calculate the position of the sampled dots relative to the viewer
eye_height = 1.5;
distance_to_target = 6;

% Get rid of those sampled dots that are behind the viewer
dotPosition = room_dots_pos(find(room_dots_pos(:, 3) > 0), :); 

% Calculate the relative position
dotPosition(:, 2) = dotPosition(:, 2) - eye_height;
dotPosition(:, 3) = dotPosition(:, 3) - (doorway_distance - distance_to_target);

save('dotPosition', 'dotPosition')


